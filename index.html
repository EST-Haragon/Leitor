<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Leitor & Reconcilia√ß√£o ‚Äî NF / Etiquetas</title>
<style>
  body { font-family: Arial, sans-serif; background:#f3f3f3; padding:18px; text-align:center; }
  #preview { width:100%; max-width:480px; height:320px; margin:10px auto; border:3px solid #555; border-radius:8px; background:#000; overflow:hidden; }
  #preview canvas { width:100% !important; height:100% !important; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin:8px 0; }
  button,label{ margin:6px; padding:10px 14px; border:none; border-radius:8px; background:#007bff; color:#fff; cursor:pointer; }
  label{ background:#28a745; }
  input[type="text"], select, input[type="date"]{ padding:8px; font-size:14px; border-radius:6px; border:1px solid #ccc; }
  textarea{ width:95%; height:90px; margin-top:8px; font-size:14px; resize:vertical; }
  #resultado{ background:#fff; padding:12px; border-radius:8px; min-height:50px; margin-top:10px; text-align:left; max-width:980px; margin-left:auto; margin-right:auto; }
  .small { font-size:13px; color:#555; }
  .warning{ color:#a94442; background:#f9e2e2; padding:8px; border-radius:6px; display:inline-block; margin-bottom:8px; }
  .topbar{ display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; margin-bottom:8px; }
  .stats { display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px; }
  .stat { background:#fff; padding:8px 10px; border-radius:8px; min-width:140px; text-align:center; }
  .stat b{ display:block; font-size:18px; }
  #progress{ font-size:13px; color:#333; margin-top:6px; }
  .muted{ color:#666; font-size:13px; }
</style>
</head>
<body>
<h2>üì¶ Leitor & Reconcilia√ß√£o ‚Äî NF / Etiquetas</h2>
<p class="small">Use em localhost ou HTTPS. Crie um lote (por loja), importe notas (PDF/TXT) ou fa√ßa leitura por c√¢mera. Registra operador e gera relat√≥rio final do dia.</p>

<div class="topbar">
  <label for="storeInput">Loja</label>
  <select id="storeSelect"></select>
  <input type="text" id="newStore" placeholder="Nova loja..." />
  <button id="addStoreBtn">‚ûï Adicionar loja</button>

  <label for="operatorInput">Operador</label>
  <input type="text" id="operatorInput" placeholder="Nome do operador" />
</div>

<div style="margin:8px auto; max-width:980px;">
  <label for="batchName">Nome do lote/expedi√ß√£o</label>
  <input type="text" id="batchName" placeholder="Ex.: Shopee - 2025-11-12 - Expedicao A" style="width:40%;" />
  <button id="createBatchBtn">üóÇÔ∏è Criar/Selecionar Lote</button>
  <div id="currentBatch" class="muted" style="margin-top:8px;"></div>
</div>

<div id="preview" aria-label="√Årea do preview da c√¢mera"></div>

<div class="controls">
  <button id="btnEsperada">1Ô∏è‚É£ Leitura Esperada (adiciona)</button>
  <button id="btnVerificada">2Ô∏è‚É£ Leitura Verificada (confirma)</button>
  <button id="btnParar" style="background:#dc3545">‚èπ Parar</button>
  <button id="btnComparar">üîç Comparar (visual)</button>
  <button id="btnRegistrarCheck" style="background:#17a2b8">üìù Registrar verifica√ß√£o atual</button>
  <button id="btnLimpar" style="background:#6c757d">üßπ Limpar lista atual</button>
</div>

<div class="stats" id="statsArea">
  <div class="stat"><span class="muted">Esperada</span><b id="statEsperada">0</b></div>
  <div class="stat"><span class="muted">Verificada</span><b id="statVerificada">0</b></div>
  <div class="stat"><span class="muted">Faltando (final)</span><b id="statFaltando">0</b></div>
  <div class="stat"><span class="muted">Sobrando (final)</span><b id="statSobrando">0</b></div>
  <div class="stat"><span class="muted">Incidentes hoje</span><b id="statIncidentes">0</b></div>
</div>

<h3>Leituras:</h3>
<textarea id="esperada" placeholder="Lista esperada (NF/etiquetas)"></textarea>
<textarea id="verificada" placeholder="Lista verificada (scanner)"></textarea>

<br>
<button id="btnExport">üíæ Exportar TXT</button>
<label for="importarTXT">üìÅ Importar TXT</label>
<input type="file" id="importarTXT" accept=".txt" style="display:none" />

<label for="importarPDF" style="background:#17a2b8">üìÑ Importar PDF</label>
<input type="file" id="importarPDF" accept="application/pdf" style="display:none" />
<div id="progress"></div>

<div style="margin-top:16px; text-align:center;">
  <label for="reportDate">Data do relat√≥rio</label>
  <input type="date" id="reportDate" />
  <button id="generateReportBtn" style="background:#28a745">üìä Gerar relat√≥rio do dia</button>
  <button id="exportReportBtn" style="background:#6f42c1">üì§ Exportar relat√≥rio (JSON)</button>
</div>

<div id="resultado"></div>

<!-- Fallback video -->
<video id="fallbackVideo" style="display:none; width:1px; height:1px;" autoplay muted playsinline></video>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<script>
/* Configs e estruturas em localStorage:
  - stores: [nomeLoja]
  - batches: [{id, name, store, operator, createdAt}]
  - data_<batchId>: {esperada:[], verificada:[]}
  - events: [{batchId, store, operator, type, code, display, ts}]
  - incidentsIndex: {dateYYYY-MM-DD: { codesWithIncidents: Set(...) }}  // opcional, recomputed
  - reports: [{date, summary, detail}]
*/

pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

const resultadoEl = document.getElementById('resultado');
const previewEl = document.getElementById('preview');
const progressEl = document.getElementById('progress');
const fallbackVideo = document.getElementById('fallbackVideo');

let currentBatchId = null;
let quaggaStarted = false;
let lastDetected = {val:null, ts:0};

// estados carregados
let stores = JSON.parse(localStorage.getItem('stores') || '[]');
let batches = JSON.parse(localStorage.getItem('batches') || '[]');
let events = JSON.parse(localStorage.getItem('events') || '[]'); // hist√≥rico de eventos
let reports = JSON.parse(localStorage.getItem('reports') || '[]');

// inicializa UI
const storeSelect = document.getElementById('storeSelect');
const operatorInput = document.getElementById('operatorInput');
const batchNameInput = document.getElementById('batchName');
const currentBatchDiv = document.getElementById('currentBatch');

function saveAll() {
  localStorage.setItem('stores', JSON.stringify(stores));
  localStorage.setItem('batches', JSON.stringify(batches));
  localStorage.setItem('events', JSON.stringify(events));
  localStorage.setItem('reports', JSON.stringify(reports));
}

function loadBatchData(batchId) {
  const key = 'data_' + batchId;
  return JSON.parse(localStorage.getItem(key) || JSON.stringify({esperada:[], verificada:[]}));
}
function saveBatchData(batchId, data) {
  localStorage.setItem('data_' + batchId, JSON.stringify(data));
}

function refreshStoreSelect() {
  storeSelect.innerHTML = '';
  stores.forEach(s => {
    const opt = document.createElement('option'); opt.value = s; opt.textContent = s;
    storeSelect.appendChild(opt);
  });
  const optOther = document.createElement('option'); optOther.value=''; optOther.textContent='-- outra --';
  storeSelect.appendChild(optOther);
}
refreshStoreSelect();

document.getElementById('addStoreBtn').addEventListener('click', () => {
  const name = document.getElementById('newStore').value.trim();
  if (!name) { alert('Informe o nome da loja.'); return; }
  if (!stores.includes(name)) { stores.push(name); saveAll(); refreshStoreSelect(); }
  document.getElementById('newStore').value = '';
});

document.getElementById('createBatchBtn').addEventListener('click', () => {
  const name = batchNameInput.value.trim();
  const store = storeSelect.value || (document.getElementById('newStore').value.trim() || null);
  const operator = operatorInput.value.trim() || null;
  if (!name || !store) { alert('Informe nome do lote e selecione/adicione a loja.'); return; }
  const id = 'batch_' + Date.now();
  const batch = { id, name, store, operator, createdAt: new Date().toISOString() };
  batches.push(batch);
  saveAll();
  currentBatchId = id;
  saveBatchData(currentBatchId, {esperada:[], verificada:[]});
  updateCurrentBatchUI();
  alert('Lote criado e selecionado: ' + name);
});

function updateCurrentBatchUI() {
  if (!currentBatchId) {
    currentBatchDiv.textContent = 'Nenhum lote selecionado';
    return;
  }
  const b = batches.find(x => x.id === currentBatchId);
  currentBatchDiv.textContent = `Lote: ${b.name} ‚Äî Loja: ${b.store} ‚Äî Operador: ${b.operator || '‚Äî'} ‚Äî Criado: ${new Date(b.createdAt).toLocaleString()}`;
  // carregar listas no textarea
  const data = loadBatchData(currentBatchId);
  document.getElementById('esperada').value = data.esperada.join('\\n');
  document.getElementById('verificada').value = data.verificada.join('\\n');
  updateStats();
}

// selecionar √∫ltimo batch criado se existir
if (batches.length) {
  currentBatchId = batches[batches.length - 1].id;
  updateCurrentBatchUI();
}

// ----- helpers de evento -----
function pushEvent(ev) {
  events.push(ev);
  saveAll();
  updateStats(); // recalcula incident counters
}

// adiciona esperado/ verificado (string exibicao j√°):
function addExpected(display) {
  if (!currentBatchId) { alert('Selecione/crie um lote antes.'); return; }
  const data = loadBatchData(currentBatchId);
  if (!data.esperada.includes(display)) {
    data.esperada.push(display);
    saveBatchData(currentBatchId, data);
    document.getElementById('esperada').value = data.esperada.join('\\n');
    pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value || null, type:'add_expected', code:display, display, ts: new Date().toISOString() });
  }
  updateStats();
}

function addVerified(display) {
  if (!currentBatchId) { alert('Selecione/crie um lote antes.'); return; }
  const data = loadBatchData(currentBatchId);
  if (!data.verificada.includes(display)) {
    data.verificada.push(display);
    saveBatchData(currentBatchId, data);
    document.getElementById('verificada').value = data.verificada.join('\\n');
    pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value || null, type:'add_verified', code:display, display, ts: new Date().toISOString() });
    // se verificado n√£o estava na esperada -> incidente "sobrou"
    if (!data.esperada.includes(display)) {
      pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value || null, type:'incident_extra', code:display, display, ts: new Date().toISOString() });
    }
  }
  updateStats();
}

// registrar manualmente check (snapshot de faltas no momento) -> marca incident_missing para cada faltante naquele momento
function recordCheckSnapshot() {
  if (!currentBatchId) { alert('Selecione/crie um lote antes.'); return; }
  const data = loadBatchData(currentBatchId);
  const faltando = data.esperada.filter(x => !data.verificada.includes(x));
  faltando.forEach(code => {
    pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value || null, type:'incident_missing', code, display:code, ts: new Date().toISOString() });
  });
  setResultado(`<p>Snapshot registrado: ${faltando.length} item(ns) marcados como faltantes neste lote.</p>`);
  updateStats();
}

// limpar listas do lote atual (n√£o apaga hist√≥rico de eventos)
function clearCurrentLists() {
  if (!currentBatchId) { alert('Selecione/crie um lote antes.'); return; }
  saveBatchData(currentBatchId, {esperada:[], verificada:[]});
  document.getElementById('esperada').value = '';
  document.getElementById('verificada').value = '';
  setResultado('<p>Listas do lote limpas (o hist√≥rico de eventos permanece).</p>');
  updateStats();
}

// atualiza estat√≠sticas e contador de incidentes (hoje)
function updateStats() {
  if (!currentBatchId) {
    document.getElementById('statEsperada').textContent = '0';
    document.getElementById('statVerificada').textContent = '0';
    document.getElementById('statFaltando').textContent = '0';
    document.getElementById('statSobrando').textContent = '0';
    document.getElementById('statIncidentes').textContent = '0';
    return;
  }
  const data = loadBatchData(currentBatchId);
  const esperadaSet = new Set(data.esperada);
  const verificadaSet = new Set(data.verificada);
  const faltandoFinal = data.esperada.filter(x => !verificadaSet.has(x));
  const sobrandoFinal = data.verificada.filter(x => !esperadaSet.has(x));
  document.getElementById('statEsperada').textContent = esperadaSet.size;
  document.getElementById('statVerificada').textContent = verificadaSet.size;
  document.getElementById('statFaltando').textContent = faltandoFinal.length;
  document.getElementById('statSobrando').textContent = sobrandoFinal.length;

  // incidentes do dia (√∫nicos) -> contamos eventos incident_missing + incident_extra do dia atual
  const today = new Date().toISOString().slice(0,10);
  const todaysIncidents = events.filter(e => (e.type === 'incident_missing' || e.type === 'incident_extra') && e.ts.slice(0,10) === today && e.batchId === currentBatchId);
  const uniqueIncidentCodes = new Set(todaysIncidents.map(i=>i.code));
  document.getElementById('statIncidentes').textContent = uniqueIncidentCodes.size;
}

// ---- Quagga / camera (mantido do c√≥digo anterior) ----
function isSecureContextAvailable() {
  return (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1');
}
function ensureCameraAccessTest() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    return Promise.reject(new Error('API navigator.mediaDevices.getUserMedia n√£o dispon√≠vel.'));
  }
  return navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
    .then(s => { s.getTracks().forEach(t => t.stop()); return Promise.resolve(); });
}

function startQuagga() {
  stopScanning();
  if (typeof Quagga === 'undefined') { setResultado('Quagga n√£o carregou.'); return; }
  Quagga.init({
    inputStream: { name:'Live', type:'LiveStream', target: previewEl, constraints:{ facingMode:'environment', width:{min:640}, height:{min:480} } },
    decoder: { readers: ["code_128_reader","ean_reader","ean_8_reader","upc_reader","upc_e_reader","code_39_reader","i2of5_reader","codabar_reader"] },
    locate:true,
    numOfWorkers: navigator.hardwareConcurrency ? Math.max(1, Math.min(4, navigator.hardwareConcurrency-1)) : 2
  }, function(err){
    if (err){ console.error('Quagga init error:',err); setResultado('Erro ao iniciar scanner: '+(err.message||err)); return; }
    Quagga.start(); quaggaStarted = true; setResultado('<b>Scanner ativo</b>');
  });

  Quagga.offDetected();
  Quagga.onDetected(function(result){
    if (!result || !result.codeResult || !result.codeResult.code) return;
    const codigo = result.codeResult.code.trim();
    const now = Date.now();
    if (lastDetected.val === codigo && (now - lastDetected.ts) < 250) return;
    lastDetected = {val:codigo, ts:now};

    // formata display (NF: if 44-digit)
    let display = codigo;
    if (/^[0-9]{44}$/.test(codigo)) {
      const numeroNota = codigo.substring(25,34);
      display = 'NF:' + parseInt(numeroNota,10);
    }

    // se modo atual for esperado ou verificado, adiciona
    if (currentMode === 'esperada') {
      addExpected(display);
    } else if (currentMode === 'verificada') {
      addVerified(display);
    }

    // a cada detec√ß√£o, tamb√©m registra incident_missing para faltantes no momento (opcional leve)
    // Aqui n√£o marcamos faltantes automaticamente a cada scan para n√£o poluir; o bot√£o "Registrar verifica√ß√£o atual" √© recomendado.
  });
}

function stopScanning() {
  if (typeof Quagga !== 'undefined' && quaggaStarted) {
    try { Quagga.stop(); } catch(e){ console.warn(e); }
    quaggaStarted = false;
  }
  if (fallbackVideo && fallbackVideo.srcObject) {
    (fallbackVideo.srcObject.getTracks()||[]).forEach(t=>t.stop());
    fallbackVideo.srcObject = null;
    fallbackVideo.style.display = 'none';
    previewEl.innerHTML = '';
  }
}

// fallback video (se Quagga falhar)
function startFallbackVideo() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    setResultado('getUserMedia n√£o suportado.');
    return;
  }
  navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' } })
    .then(stream => {
      fallbackVideo.srcObject = stream; fallbackVideo.style.display='block'; previewEl.innerHTML=''; previewEl.appendChild(fallbackVideo);
    })
    .catch(err => { console.error(err); setResultado('N√£o foi poss√≠vel abrir c√¢mera: '+err.message); });
}

// modo de leitura
let currentMode = null;
document.getElementById('btnEsperada').addEventListener('click', () => {
  currentMode = 'esperada';
  if (!isSecureContextAvailable()) { setResultado('<div class="warning">Use HTTPS/localhost para c√¢mera.</div>'); return; }
  ensureCameraAccessTest().then(()=> startQuagga()).catch(err=> setResultado('Erro acesso c√¢mera: '+err.message));
});
document.getElementById('btnVerificada').addEventListener('click', () => {
  currentMode = 'verificada';
  if (!isSecureContextAvailable()) { setResultado('<div class="warning">Use HTTPS/localhost para c√¢mera.</div>'); return; }
  ensureCameraAccessTest().then(()=> startQuagga()).catch(err=> setResultado('Erro acesso c√¢mera: '+err.message));
});
document.getElementById('btnParar').addEventListener('click', () => { stopScanning(); setResultado('Scanner parado.'); });
document.getElementById('btnRegistrarCheck').addEventListener('click', () => recordCheckSnapshot());
document.getElementById('btnLimpar').addEventListener('click', () => clearCurrentLists());
document.getElementById('btnComparar').addEventListener('click', () => {
  if (!currentBatchId) { alert('Selecione um lote.'); return; }
  const data = loadBatchData(currentBatchId);
  const faltando = data.esperada.filter(x=>!data.verificada.includes(x));
  const aMais = data.verificada.filter(x=>!data.esperada.includes(x));
  let html = '<h3>Resultado da compara√ß√£o</h3>';
  html += `<p><b>Faltando (${faltando.length}):</b><br>${faltando.join('<br>') || '‚Äî'}</p>`;
  html += `<p><b>A mais (${aMais.length}):</b><br>${aMais.join('<br>') || '‚Äî'}</p>`;
  setResultado(html);
});

// Export / Import TXT
document.getElementById('btnExport').addEventListener('click', () => {
  if (!currentBatchId) { alert('Selecione um lote.'); return; }
  const data = loadBatchData(currentBatchId);
  const obj = { batchId: currentBatchId, batchInfo: batches.find(b=>b.id===currentBatchId), data };
  const blob = new Blob([JSON.stringify(obj, null, 2)], { type:'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'dados_lote_' + currentBatchId + '.txt'; a.click(); URL.revokeObjectURL(url);
});
document.getElementById('importarTXT').addEventListener('change', (e) => {
  const f = e.target.files[0]; if (!f) return;
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const obj = JSON.parse(ev.target.result);
      if (obj.esperada || obj.verificada) { // formato antigo
        if (!currentBatchId) { alert('Crie/seleccione um lote antes de importar.'); return; }
        const data = loadBatchData(currentBatchId);
        data.esperada = Array.from(new Set([...data.esperada, ...(obj.esperada||[])]));
        data.verificada = Array.from(new Set([...data.verificada, ...(obj.verificada||[])]));
        saveBatchData(currentBatchId, data);
        document.getElementById('esperada').value = data.esperada.join('\\n');
        document.getElementById('verificada').value = data.verificada.join('\\n');
        data.esperada.forEach(d=> pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value||null, type:'add_expected', code:d, display:d, ts:new Date().toISOString() }));
        data.verificada.forEach(d=> pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value||null, type:'add_verified', code:d, display:d, ts:new Date().toISOString() }));
        setResultado('Importado TXT para lote atual.');
      } else if (obj.data && obj.batchId) {
        // import de export anterior
        if (!currentBatchId) { alert('Selecione/crie um lote antes de importar.'); return; }
        const data = loadBatchData(currentBatchId);
        data.esperada = Array.from(new Set([...data.esperada, ...obj.data.esperada]));
        data.verificada = Array.from(new Set([...data.verificada, ...obj.data.verificada]));
        saveBatchData(currentBatchId, data);
        setResultado('Dados importados no lote atual.');
      } else {
        setResultado('Arquivo TXT inv√°lido.');
      }
    } catch(err) { setResultado('Erro importando TXT: ' + err.message); }
  };
  reader.readAsText(f);
});

// PDF import (mantido do c√≥digo anterior, adiciona ao lote como esperada automaticamente)
document.getElementById('importarPDF').addEventListener('change', async (e) => {
  const file = e.target.files[0]; if (!file) return;
  if (!currentBatchId) { alert('Crie/seleccione um lote antes de importar PDF.'); return; }
  setProgress('Carregando PDF...');
  try {
    const arrayBuffer = await file.arrayBuffer();
    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    const total = pdf.numPages;
    setProgress(`Processando PDF: ${total} p√°gina(s)...`);
    const foundCodes = [];
    for (let i = 1; i <= total; i++) {
      setProgress(`P√°gina ${i} / ${total}...`);
      const page = await pdf.getPage(i);
      const viewport = page.getViewport({ scale: 2.0 });
      const canvas = document.createElement('canvas');
      canvas.width = Math.round(viewport.width);
      canvas.height = Math.round(viewport.height);
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;

      // BarcodeDetector nativo
      let detectedOnPage = [];
      if (window.BarcodeDetector) {
        try {
          const formats = ['code_128','ean_13','ean_8','upc_e','upc_a','code_39','itf','codabar','pdf417','qr_code'];
          const detectorFormats = formats;
          const detector = new BarcodeDetector({ formats: detectorFormats });
          const barcodes = await detector.detect(canvas);
          detectedOnPage = (barcodes||[]).map(b => (b.rawValue || b.displayValue || '').trim()).filter(Boolean);
        } catch(err) { console.warn('BarcodeDetector err',err); }
      }

      if (detectedOnPage.length === 0) {
        try {
          const dataUrl = canvas.toDataURL('image/png');
          const qResult = await new Promise(resolve => {
            Quagga.decodeSingle({
              src: dataUrl,
              numOfWorkers: 0,
              decoder: { readers: ["code_128_reader","ean_reader","ean_8_reader","upc_reader","upc_e_reader","code_39_reader","i2of5_reader","codabar_reader"] },
              locate: true
            }, function(r){ resolve(r); });
          });
          if (qResult && qResult.codeResult && qResult.codeResult.code) detectedOnPage = [ qResult.codeResult.code.trim() ];
        } catch(err) { console.warn('Quagga decodeSingle err', err); }
      }

      detectedOnPage.forEach(code => {
        let display = code;
        if (/^[0-9]{44}$/.test(code)) {
          display = 'NF:' + parseInt(code.substring(25,34),10);
        }
        if (!foundCodes.includes(display)) foundCodes.push(display);
      });
      canvas.width = 0; canvas.height = 0;
    }

    // adiciona encontrados √† esperada do lote e registra eventos
    const data = loadBatchData(currentBatchId);
    foundCodes.forEach(d => { if (!data.esperada.includes(d)) { data.esperada.push(d); pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value||null, type:'add_expected', code:d, display:d, ts:new Date().toISOString() }); } });
    saveBatchData(currentBatchId, data);
    document.getElementById('esperada').value = data.esperada.join('\\n');
    setResultado(`<p style="color:green">Importados do PDF: ${foundCodes.length} c√≥digo(s).</p>`);
    setProgress('');
  } catch(err) {
    console.error(err);
    setResultado('Erro ao processar PDF: ' + err.message);
    setProgress('');
  }
});

function setResultado(html) { resultadoEl.innerHTML = html; }
function setProgress(t) { progressEl.textContent = t || ''; }

// Report generation (manual) ‚Äî por data (YYYY-MM-DD)
document.getElementById('generateReportBtn').addEventListener('click', () => {
  const date = document.getElementById('reportDate').value || (new Date().toISOString().slice(0,10));
  const report = generateDailyReport(date);
  // mostra no UI
  let html = `<h3>Relat√≥rio para ${date}</h3>`;
  html += `<p><b>Total esperada (√∫nicos):</b> ${report.totalEsperada}</p>`;
  html += `<p><b>Total verificada (√∫nicos):</b> ${report.totalVerificada}</p>`;
  html += `<p><b>Faltando (final):</b> ${report.faltando.length}</p>`;
  html += `<p><b>Sobrando (final):</b> ${report.sobrando.length}</p>`;
  html += `<p><b>Incidentes (faltou) √∫nicos durante o dia:</b> ${report.incidentesFaltou.length}</p>`;
  html += `<p><b>Incidentes (sobrou) √∫nicos durante o dia:</b> ${report.incidentesSobrou.length}</p>`;
  html += `<details><summary>Faltando (lista)</summary><div>${report.faltando.join('<br>') || '‚Äî'}</div></details>`;
  html += `<details><summary>Sobrando (lista)</summary><div>${report.sobrando.join('<br>') || '‚Äî'}</div></details>`;
  setResultado(html);
  // salvar snapshot em reports (opcional)
  reports.push({ date, ts: new Date().toISOString(), summary: { totalEsperada:report.totalEsperada, totalVerificada:report.totalVerificada, faltando:report.faltando.length, sobrando:report.sobrando.length, incidentesFaltou:report.incidentesFaltou.length, incidentesSobrou:report.incidentesSobrou.length }, detail: report });
  saveAll();
});

document.getElementById('exportReportBtn').addEventListener('click', () => {
  const date = document.getElementById('reportDate').value || (new Date().toISOString().slice(0,10));
  const report = generateDailyReport(date);
  const blob = new Blob([JSON.stringify(report, null, 2)], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `report_${date}.json`; a.click(); URL.revokeObjectURL(url);
});

// gera relat√≥rio para a data: considera todos os batches criados nessa data (e eventos do dia)
function generateDailyReport(dateYYYYMMDD) {
  // eventos do dia
  const eventsDay = events.filter(e => e.ts.slice(0,10) === dateYYYYMMDD);
  // batches envolvidos no dia (criados nesse dia OR with events)
  const batchIds = new Set(eventsDay.map(e=>e.batchId));
  // Tamb√©m inclui batches que foram criados nesse dia
  batches.forEach(b => { if (b.createdAt.slice(0,10) === dateYYYYMMDD) batchIds.add(b.id); });

  const report = { date: dateYYYYMMDD, batches: {}, totalEsperada:0, totalVerificada:0, faltando:[], sobrando:[], incidentesFaltou:[], incidentesSobrou:[] };

  batchIds.forEach(batchId => {
    const batch = batches.find(b=>b.id===batchId) || { id:batchId, name:'(desconhecido)', store:'(desconhecido)' };
    const data = loadBatchData(batchId);
    const esperadaSet = new Set(data.esperada);
    const verificadaSet = new Set(data.verificada);

    const faltandoFinal = Array.from(esperadaSet).filter(x => !verificadaSet.has(x));
    const sobrandoFinal = Array.from(verificadaSet).filter(x => !esperadaSet.has(x));

    // incidentes no dia: eventos incident_missing/incident_extra
    const inciFaltou = new Set(eventsDay.filter(e=>e.batchId===batchId && e.type==='incident_missing').map(e=>e.code));
    const inciSobrou = new Set(eventsDay.filter(e=>e.batchId===batchId && e.type==='incident_extra').map(e=>e.code));

    report.batches[batchId] = {
      info: batch,
      totalEsperada: esperadaSet.size,
      totalVerificada: verificadaSet.size,
      faltandoFinal,
      sobrandoFinal,
      incidentesFaltou: Array.from(inciFaltou),
      incidentesSobrou: Array.from(inciSobrou),
      events: eventsDay.filter(e=>e.batchId===batchId)
    };

    // agregar ao resumo
    report.totalEsperada += esperadaSet.size;
    report.totalVerificada += verificadaSet.size;
    report.faltando.push(...faltandoFinal);
    report.sobrando.push(...sobrandoFinal);
    report.incidentesFaltou.push(...Array.from(inciFaltou));
    report.incidentesSobrou.push(...Array.from(inciSobrou));
  });

  // Uniques
  report.faltando = Array.from(new Set(report.faltando));
  report.sobrando = Array.from(new Set(report.sobrando));
  report.incidentesFaltou = Array.from(new Set(report.incidentesFaltou));
  report.incidentesSobrou = Array.from(new Set(report.incidentesSobrou));
  return report;
}

// input label clicks
document.querySelector('label[for="importarTXT"]').addEventListener('click', ()=> document.getElementById('importarTXT').click());
document.querySelector('label[for="importarPDF"]').addEventListener('click', ()=> document.getElementById('importarPDF').click());

// ao recarregar, atualizar stats
window.addEventListener('load', () => {
  // se batches existir, pre-seleciona √∫ltimo
  if (batches.length && !currentBatchId) { currentBatchId = batches[batches.length-1].id; }
  updateCurrentBatchUI();
});

// salvar quando textarea alterada manualmente
document.getElementById('esperada').addEventListener('change', () => {
  if (!currentBatchId) return;
  const data = loadBatchData(currentBatchId);
  data.esperada = document.getElementById('esperada').value.split('\\n').map(s=>s.trim()).filter(Boolean);
  saveBatchData(currentBatchId, data);
  // registra eventos de adi√ß√£o (simplificado)
  data.esperada.forEach(d => pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value||null, type:'add_expected', code:d, display:d, ts:new Date().toISOString() }));
});
document.getElementById('verificada').addEventListener('change', () => {
  if (!currentBatchId) return;
  const data = loadBatchData(currentBatchId);
  data.verificada = document.getElementById('verificada').value.split('\\n').map(s=>s.trim()).filter(Boolean);
  saveBatchData(currentBatchId, data);
  data.verificada.forEach(d => pushEvent({ batchId: currentBatchId, store: batches.find(b=>b.id===currentBatchId).store, operator: operatorInput.value||null, type:'add_verified', code:d, display:d, ts:new Date().toISOString() }));
});

// Atualiza UI de stores sempre que alterar lista global
window.addEventListener('storage', () => { stores = JSON.parse(localStorage.getItem('stores') || '[]'); batches = JSON.parse(localStorage.getItem('batches') || '[]'); events = JSON.parse(localStorage.getItem('events') || '[]'); refreshStoreSelect(); });

// mensagem inicial sobre seguran√ßa
if (!isSecureContextAvailable()) {
  setResultado('<div class="warning">Aten√ß√£o: a c√¢mera funciona apenas em HTTPS ou localhost. Importa√ß√£o de PDF funciona localmente.</div>');
}
</script>
</body>
</html>